# [__Meng](https://www.cnblogs.com/mengchunchen/)

- [博客园](https://www.cnblogs.com/)
- [首页](https://www.cnblogs.com/mengchunchen/)
- [新随笔](https://i.cnblogs.com/EditPosts.aspx?opt=1)
- [联系](https://msg.cnblogs.com/send/__Meng)
- [订阅](javascript:void(0))
- [管理](https://i.cnblogs.com/)

随笔 - 641 文章 - 0 评论 - 36 阅读 - 88万

# [如何保证消息不被重复消费（如何保证消息消费时的幂等性）](https://www.cnblogs.com/mengchunchen/p/10007537.html)

 

# 重复消费可能会在什么场景下出现（以kafka为例）

![img](..\images\kafka\05_06_01_A_01_分布式存储核心组件_kafka_基础-应用2-重复消费-幂等性_01.png)

 

　　kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，

　　然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的offset来继续消费吧。  

　　但是凡事总有意外，就是你有时候重启系统，直接kill进程了，再重启。这会导致consumer有些消息处理了，但是没来得及提交offset。

　　重启之后，少数消息会再次消费一次。  

　　其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。  

　　假设你有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下已经消费过了，直接扔了，不就保留了一条数据？  一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性  幂等性，我通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。

 

# 怎么保证消息队列消费的幂等性？

![img](..\images\kafka\05_06_01_A_01_分布式存储核心组件_kafka_基础-应用2-重复消费-幂等性_02.png)

 

如何保证MQ的消费是幂等性的，需要结合具体的业务来看 ：

　　比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧 

　　比如你是写redis，那没问题了，反正每次都是set，天然幂等性  

　　比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。  

　　还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据  

 

转自：中华石杉Java工程师面试突击