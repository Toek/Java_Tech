# 前言

在数据库调优中，我们的目标就是`响应时间更快，吞吐量更大`。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。

# 一、数据库服务器的优化步骤

当我们遇到数据库调优问题的时候，该如何思考呢? 这里把思考的流程整理成下面这张图。

整个流程划分成了`观察(Show status)`和`行动(Action)`两个部分。字母S的部分代表观察(会使用相应的分析工具)，字母A代表的部分是行动 (对应分析可以采取的行动)。

![img](..\images\mysql\209-01.png)



我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的 SOL都有哪些，查看具体的 SQL 执行计划，甚至是 SQL 执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。

**详细解释一下这张图:**

首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动。如果`存在周期性波动`，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过 A1 这一步骤解决，也就是加缓存，或者更改缓存失效策略。

如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步`分析查询延迟和卡顿的原因`。接下来进入S2这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的 SQL 语。我们可以通过设置`long_query_time `参数定义“慢”的闻值，如果 SQL 执行时间超过了long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢询日志进行分析。

在S3 这一步骤中，我们就知道了执行的 SQL，这样就可以针对性地用`EXPLAIN`查看对应 SQL 语句的执行计划，或者使用`show profile`查看 SQL 中每一个步骤的时间成本。这样我们就可以了解 SQL 查询慢是因为执行时间长，还是等待时间长。

如果是 SQL 等待时间长，我们进入A2 步骤。在这一步骤中，我们可以`调优服务器的参数`，比如适当增加数据库缓冲池等。如果是 SQL执行时间长，就进入A3 步骤，这一步中我们需要考虑是索引设计的问题?还是查询关联的数据表过多？还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。

如果 A2和 A3都不能解决问题，我们需要考虑数据库自身的 SQL 查询性能是否已经达到了瓶颈，如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤。如果已经达到了`性能瓶颈`，进入 A4 阶段，需要考虑`增加服务器`，采用`读写分离`的架构，或者考虑对数据库进行`分库分表`，比如垂直分库、垂直分表和水平分表等。

以上就是数据库调优的流程思路。如果我们发现执行 SQL 时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的 SQL，这三种分析工具你可以理解是 SQL 调优的三个步骤: `慢查询`、`EXPLAIN`和 `SHOW PROFILING`。

**小结：**



![img](..\images\mysql\209-02.png)

# 二、查看系统性能参数

在MySQL中，可以使用`SHOW STATUS`语句查询一些MySQL数据库服务器的`性能参数`、`执行频率`。

SHOW STATUS语句语法如下:

```mysql
SHOW [GLOBAL|SESSION] STATUS LIKE '参数';
```

一些常用的性能参数如下:

·Connections: 连接MySQL服务器的次数

·Uptime: MySQL服务器的上线时间

·Slow_queries: 慢查询的次数。

·Innodb_rows_read: Select查询返回的行数

·Innodb_rows_inserted: 执行INSERT操作插入的行数

·Innodb_rows_updated: 执行UPDATE操作更新的行数

·Innodb_rows_deleted: 执行DELETE操作删除的行数

·Com_select:查询操作的次数

·Com_insert: 插入操作的次数。对于批量插入的INSERT 操作，只累加一次

·Com_update:更新操作的次数

·Com_delete: 删除操作的次数

- 若查询MySQL服务器的连接次数，则可以执行如下语句:

```mysql
SHOW STATUS LIKE 'Connections';
```

- 若查询服务器工作时间，则可以执行如下语句:

```mysql
SHOW STATUS LIKE 'Uptime';
```

- 若查询MySQL服务器的慢查询次数，则可以执行如下语句:

```mysql
SHOW STATUS LIKE 'Slow_queries';
```

慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行`表结构优化`或者`查询语句优化`。

再比如，如下的指令可以查看相关的指令情况:

```mysql
SHOW STATUS LIKE 'Innodb_rows_%' :
```

# 三、统计SQL的查询成本: last_query_cost

一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择`成本最小`的一个作为最终执行的执行计划。

如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的last_query_cost 变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率 的一个常用指标。这个查询成本对应的是 SQL 语句所需要读取的页的数量。

我们依然使用第8章的 student_info 表为例:

```mysql
CREATE TABLE `student_info` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`student_id` INT NOTNULL,
`name`  VARCHAR(20) DEFAULT NULL,
`course_id` INT NOT NULL,
`class_id` INT(11) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

 如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找

```mysql
SELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001:
```

然后再看下查询优化器的成本，实际上我们只需要检索一个页即可:

```mysql
SHOW STATUS LIKE 'last_query_cost';
```

如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢?

```mysql
SELECT student_id, class_id, NAME, createtime FROM student_infoWHERE id BETWEEN 900001 AND 900109:
```

然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。

```mysql
SHOW STATUS LIKE 'last_query_cost';
```

你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SOL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然`页数量(last_query_cost) 增加了不少` ，但是通过缓冲池的机制, 并`没有增加多少查询时间`。

**使用场景:** 它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候

> SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论:
>
> 1. `位置决定效率`。如页就在数据库`缓冲池`中，那么效率是最高的，否则还需要从`内存`或者`磁盘`中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
> 2. `批量决定效率`。如果我们从磁盘中对单一页进行随机读，那么效率是很低的 (差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。
>
> 所以说，遇到I/0并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到`缓冲池`中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

# 四、定位执行慢的 SQL:慢查询日志

MySQL的慢查询日志，用来记录在MySQL中`响应时间超过阀值`的语句，具体指运行时间超过`long-query_time`值的SQL，则会被记录到慢查询日志中。 long_query_time的默认值为`10`，意思是运行10秒以上(不含10秒)的语句，认为是超出了我们的最大忍耐时间值。

它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻寒、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。

默认情况下，MySQL数据库`没有开启慢查询日志`，需要我们手动来设置这个参数。**如果不是调优需要的话，一般不建议启动该参数**，因为开启慢查询日志会或多或少带来一定的性能影响。

慢查询日志支持将日志记录写入文件。

## 4.1 开启慢查询日志参数

**1.开启slow_query_log**

在使用前，我们需要先看下慢查询是否已经开启，使用下面这条命令即可:

```mysql
show variables like "%slow_query_log';
```

我们能看到`slow_query_log=OFF`，我们可以把慢查询日志打开，注意设置变量值的时候需要使用 global，否则会报错:

```mysql
set global slow_query_log='ON';
```

然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置:

```mysql
show variables like "%slow_query_log';
```

你能看到这时慢查询分析已经开启，同时文件保存在 `/var/lib/mysql/xxx.log`文件中。

**2.修改long_query_time阈值**

接下来我们来看下慢查询的时间阈值设置，使用如下命令:

```mysql
show variables like '%long_query_time%':
```

这里如果我们想把时间缩短，比如设置为1秒，可以这样设置:

```mysql
#测试发现:设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语包
set global long_query_time = 1:
show global variables like '%long_query_time%';
set long_query_time=1;
show variables like '%long_query_time%';
```

**补充: 配置文件中一并设置参数**

如下的方式相较于前面的命令行方式，可以看作是永久设置的方式。

修改`my.cnf`文件，[mysqld]下增加或修改参数`long_query_time`、`slow_query_log`和`slow_query_log_file`后，然后重启MySQL服务器。

```properties
[mysqld]
slow_query_log=ON # 开启慢查询日志的开关
slow_query_log_file=/var/lib/mysql/atguigu-slow.log #慢查询日志的目录和文件名信息
long_query_time=3 #设置慢查询的阅值为3秒，超出此设定值的SQL即被记录到慢查询日志
log_output=FILE
```

如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname-slow.log。

## 4.2 查看慢查询数目

查询当前系统中有多少条慢查询记录

```mysql
SHOW GLOBAL STATUS LIKE %Slow_queries%';
```

## 4.3 案例演示

步骤1.建表

```mysql
CREATE TABLE `student`(
	`id` INT(11) NOT NULL AUTO_INCREMENT,
    `stuno` INT NOT NULL,
    `name` VARCHAR(20) DEFAULT NULL,
    `age` INT(3) DEFAULT NULL,
    `classId` INT(11) DEFAULT NULL,
    PRIMARY KEY (`id`)
)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

**步骤2: 设置参数 log_bin_trust_function_creators**

创建函数，假如报错:

```log
This function has none of DETERMINISTIC......
```

命令开启: 允许创建函数设置

```mysql
set global log_bin_trust_function_creators=1;  #不加global只是当前窗口有效。
```

**步骤3: 创建函数**

随机产生字符串:

```mysql
DELIMITER //
CREATE FUNCTION rand_string (n INT)
	RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT
	'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END //
DELIMITER ;
```

产生随机数值：

```mysql
DELIMITER //
CREATE FUNCTION rand_num ( from_num INT, to_num INT ) RETURNS INT ( 11 ) 
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR( from_num + RAND() * ( to_num - from_num + 1 ) );
RETURN i;
END // 
DELIMITER;

SELECT rand_num(10,100);
```

**步骤4:创建存储过程**

```mysql
DELIMITER //
CREATE PROCEDURE insert_stu1( START INT, max_num INT )
BEGIN
DECLARE I INT DEFAULT 0;
	SET autocommit = 0; #设手动提交事务
	REPEAT #循环
	SET i = i + 1; #赋值
	INSERT INTO student (stuno, NAME ,age ,classId ) VALUES
	((START+i), rand_string(6),rand_num(10, 100), rand_num(10, 1000)) ;
	UNTIL i = max_num
	END REPEAT ;
	COMMIT; #提交事务
END //
DELIMITER ;
```

**步骤5: 调用存储过程**

```mysql
#调用刚刚写好的函数，4000000条记录,从100001号开始
CALL insert_stu1(100001,4000000);
```

## 4.4 测试及分析

**1.测试**

```mysql
SELECT * FROM student WHERE stuno = 3455655;


SELECT * FROM student WHERE name = 'oQmLUr'
```

从上面的结果可以看出来，查询学生编号为"3455655"的学生信息花费时间为2.09秒。查询学生姓名为"oQmLUr"的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面的小节我们分析一下原因。

**2.分析**

```mysql
show status like 'slow_queries';
```

> **补充说明：**
>
> 除了上述变量，控制慢查询日志的还有一个系统变量: min_examined_row_limit。这个变量的意思是，查询`扫描过的最少记录数`。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并目查询执行时间超过 long_query_time 的值，那么，这个查询就被记录到慢查询日志中;反之，则不被记录到慢查询日志中。
>
> ```mysql
> show variables like "min%':
> ```
>
> 这个值默认是0。与long_query_time=10 合在一起，表示只要查询的执行时间超过 10 秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改“my.ini"文件，来修改查询时长，或者通过 SET 指令，用SQL语句修改“min_examined_row_limit”的值

## 4.5 慢查询日志分析工具: mysqldumpslow

在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具`mysqldumpslow`。

查看mysqldumpslow的帮助信息

```mysql
mysqldumpslow --help
```

mysqldumpslow 命令的具体参数如下:

- -a: 不将数字抽象成N，字符串抽象成Ss

- <b style="color:red">-s: 是表示按照何种方式排序:</b>

  - c: 访问次数

  - l: 锁定时间

  - r: 返回记录

  - **t: 查询时间**

  - al:平均锁定时间

  - ar:平均返回记录数

  - at:平均查询时间 (默认方式)

  - ac:平均查询次数

- <b style="color:red">-t: 即为返回前面多少条的数据</b>
- <b style="color:red">-g: 后边搭配一个正则匹配模式，大小写不敏感的;</b>

举例: 我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可:

```shell
mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu81-slow.log
```

```mysql
#得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log
#另外建议在使用这些命令时结合  和more 使用 ，否则有可能出现爆屏情况
mysqldumpslow -s r -t 10 /var/lib/mysql/atquigu-slow.log | more
```

## 4.6 关闭慢查询日志

MySQL服务器停止慢查询日志功能有两种方法:

**方式1:永久性方式**

修改my.cnf或者my.ini文件，把[mysqld]组下的slow_query_log值设置为OFF，修改保存后，再重启MySQL服务，即可生效:

```properties
[mysqld]
slow_query_log=OFF
```

或者，把slow_query_log一项注释掉或删除

```properties
[mysqld]
#slow_query_log =OFF
```

重启MySQL服务，执行如下语句查询慢日志功能。

```mysql
SHOW VARIABLES LIKE '%slow%'; #查询慢查询日志所在目录
SHOW VARIABLES LIKE '%long_query_time%'; #查询超时时长
```

可以看到，MySQL系统中的慢查询日志是关闭的。

**方式2:临时性方式**

使用SET语句来设置。

(1)停止MySQL慢查询日志功能，具体SQL语句如下。

```mysql
SET GLOBAL slow_query_log=off;
```

(2)<b style="color:red">重启MySQL服务</b>，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下

```mysql
SHOW VARIABLES LIKE '%slow%';
#以及
SHOW VARIABLES LIKE '%long_query_time%';
```

## 4.7 删除慢查询日志

使用SHOW语句显示慢查询日志信息，具体SQL语句如下。

```mysql
SHOW VARIABLES LIKE 'slow_query_log%';
```

从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下`手动删除慢查询日志文件`即可。

使用命令`mysqladmin flush-logs`来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。

```shell
mysqladmin -uroot -p flush-logs slow
```

> 提示:
> 慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

# 五、查看 SQL执行成本: SHOW PROFILE

show profile在[《逻辑架构》](./204_逻辑架构.md "#2.2.3 查看profiles")章节中讲过，这里作为复习。

Show Profile是MySQL提供的可以用来分析当前会话中SQL 都做了什么、执行的资源消耗情况的工具，可用于sql调优的测量。 `默认情况下处于关闭状态`，并保存最近15次的运行结果。

我们可以在会话级别开启这个功能

```mysql
show variables like 'profiling';
```

通过设置 profiling='ON'来开启 show profile:

```mysql
set profiling = 'ON';
```

然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：

```mysql
show profiles;
```

你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：

```mysql
show profile;
```

我们也可以查看指定的 Query ID 的开销，比如 show profile for query 2 查询结果是一样的。在 SHOW PROFILE 中我们可以查看不同部分的开销，比如 cpu、block io 等:

```mysql
show profile cpu, block io for query 2;
```

通过上面的结果，我们可以弄清楚每一步骤的耗时，以及在不同部分，比如 CPU、block.io 的执行时间，这样我们就可以判断出来 SQL到底慢在哪里。

**show profile的常用查询参数:**

① ALL: 显示所有的开销信息
② BLOCK 10:显示块10开销
③ CONTEXT SWITCHES:上下文切换开销
④ CPU:显示CPU开销信息。
⑤ IPC:显示发送和接收开销信息
⑥ MEMORY:显示内存开销信息。
⑦ AGE FAULTS:显示页面错误开销信息。
⑧ SOURCE: 显示和Source function，Source_file，Source_line相关的开销信息
⑨ SWAPS:显示交换次数开销信息。

**日常开发需注意的结论:**

①`converting HEAP to MyISAM`: 查询结果太大，内存不够，数据往磁盘上搬了

②`Creating tmp table`: 创建临时表。先拷贝数据到临时表，用完后再删除临时表

③`Copying to tmp table on disk`: 把内存中临时表复制到磁盘上，警惕!

④`locked` 

如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。

**注意:**

不过 SHOW PROFILE 命令将被弃用，我们可以从 information_schema 中的 profiling 数据表进行查看。

# 六、分析查询语句: EXPLAIN

## 6.1 概述

**定位了查询慢的 SQL 之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。**DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。

MySQL中有专门负责优化SELECT语句的优化器模块，主要功能: 通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的`执行计划`(他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。

这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了`EXPLAIN`语句来帮助我们查看某个查询语句的具体执行计划，大家看懂`EXPLAIN`语句的各个输出项，可以有针对性的提升我们查询语句的性能。

**1.能做什么?**

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- <b style="color:red">哪些索引被实际使用</b>
- 表之间的引用
- <b style="color:red">每张表有多少行被优化器查询</b>

**2.官网介绍**

https://dev.mysql.com/doc/refman/5.7/en/explain-output.html

https://dev.mysql.com/doc/refman/8.0/en/explain-output.html

**3.版本情况**

- MySQL5.6.3以前只能`EXPLAIN SELECT`; MYSQL5.6.3以后就可以`EXPLAIN SELECT，UPDATE，DELETE`
- 在5.7以前的版本中，想要显示`partitions`需要使用`explain partitions`命令，想要显示`filtered`需要使用`explain extended`命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。

## 6.2 基本语法

EXPLAIN 或DESCRIBE语句的语法形式如下：

```mysql
EXPLAIN SELECT select_options
或者
DESCRIBE SELECT select_options
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个`EXPLAIN`，就像这样:

```mysql
EXPLAIN SELECT 1;
```

输出的上述信息就是所谓的`执行计划`。在这个执行计划的辅助下，我们需要知道应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以`SELECT`开头的查询语句，其余的`DELETE`、`INSERT`、`REPLACE`以及`UPDATE`语句等都可以加上`EXPLAIN`，用来查看这些语句的执行计划，只是平时我们对`SELECT`语句更感兴趣

注意: 执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划.

`EXPLAIN`语句输出的各个列的作用如下:

| 列名            | 描述                                                     |
| --------------- | -------------------------------------------------------- |
| `id`            | 在一个大的查询语句中每个SELECT关键字都对应一个`唯一的id` |
| `select_type`   | SELECT关键字对应的那个查询的类型                         |
| `table`         | 表名                                                     |
| `partitions`    | 匹配的分区信息                                           |
| `type`          | 针对单表的访问方法                                       |
| `possible_keys` | 可能用到的索引                                           |
| `key`           | 实际上使用的索引                                         |
| `key_len`       | 实际使用到的索引长度                                     |
| `ref`           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息   |
| `rows`          | 预估的需要读取的记录条数                                 |
| `filtered`      | 某个表经过搜索条件过滤后剩余记录条数的百分比             |
| `Extra`         | 一些额外的信息                                           |

在这里把它们都列出来只是为了描述一个轮廓，让大家有一个大致的印象。

## 6.3 数据准备

1.建表

```mysql
CREATE TABLE s1(
	id INT AUTO_INCREMENT,
	key1 VARCHAR(100),
	key2 INT,
	key3 VARCHAR(100),
	key_part1 VARCHAR(100),
	key_part2 VARCHAR(100),
	key_part3 VARCHAR(100),
	common_field VARCHAR(100),
	PRIMARY KEY (id),
	INDEX idx_key1(key1),
	UNIQUE INDEX idx_key2(key2),
	INDEX idx_key3(key3),
	INDEX idx_key_part(key_part1,key_part2,key_part3)
)ENGINE=INNODB CHARSET=utf8;
```

```mysql
CREATE TABLE s2(
	id INT AUTO_INCREMENT,
	key1 VARCHAR(100),
	key2 INT,
	key3 VARCHAR(100),
	key_part1 VARCHAR(100),
	key_part2 VARCHAR(100),
	key_part3 VARCHAR(100),
	common_field VARCHAR(100),
	PRIMARY KEY (id),
	INDEX idx_key1(key1),
	UNIQUE INDEX idx_key2(key2),
	INDEX idx_key3(key3),
	INDEX idx_key_part(key_part1,key_part2,key_part3)
)ENGINE=INNODB CHARSET=utf8;
```

**2.设置参数 log_bin_trust_function_creators**

创建函数，假如报错，需开启如下命令: 允许创建函数设置:

```mysql
set global log_bin_trust_function_creators=1; # 不加globa1只是当前窗口有效。
```

**3.创建函数**

```mysql
DELIMITER //
CREATE FUNCTION rand_string (n INT)
	RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
	DECLARE chars_str VARCHAR(100) DEFAULT
	'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	WHILE i < n DO
		SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END //
DELIMITER ;
```

**4.创建存储过程**

创建往s1表中插入数据的存储过程:

```mysql
DELIMITER //
CREATE PROCEDURE insert_s1(IN min_num INT(10),IN max_num INT(10))
BEGIN
	DECLARE i INT DEFAULT 0;
	SET autocommit = 0;
	REPEAT
	SET i = i + 1;
	INSERT INTO s1 VALUES(
	(min_num + i),
	rand_string(6),
	(min_num + 30 * i + 5),
	rand_string(6),
	rand_string(10),
	rand_string(5),
	rand_string(10),
	rand_string(10)
	);
	UNTIL i = max_num
	END REPEAT;
	COMMIT;
END //
DELIMITER;
```

创建往s2表中插入数据的存储过程:

```mysql
DELIMITER //
CREATE PROCEDURE insert_s2(IN min_num INT(10),IN max_num INT(10))
BEGIN
	DECLARE i INT DEFAULT 0;
	SET autocommit = 0;
	REPEAT
	SET i = i + 1;
	INSERT INTO s2 VALUES(
	(min_num + i),
	rand_string(6),
	(min_num + 30 * i + 5),
	rand_string(6),
	rand_string(10),
	rand_string(5),
	rand_string(10),
	rand_string(10)
	);
	UNTIL i = max_num
	END REPEAT;
	COMMIT;
END //
DELIMITER;
```

**5.调用存储过程**

s1表数据的添加: 加入1万条记录:

```mysql
CALL insert_s1(10001,10000);
```

s2表数据的添加: 加入1万条记录:

```mysql
CALL insert_s2(10001,10000);
```

## 6.4 EXPLAIN各列作用

为了让大家有比较好的体验，我们调整了下`EXPLAIN`输出列的顺序

### 1.table

不论我们的查询语句有多复杂，里边儿`包含了多少个表`，到最后也是需要对每个表进行`单表访问`的，所以MySQL规定**EXPLAIN语句输出的每条记录都对应着某个单表的访问方法**，该条记录的table列代表着该表的表名(有时不是真实的表名字，可能是简称)。

```mysql
 EXPLAIN SELECT * FROM s1;
```

![img](..\images\mysql\209-03.png)

这个查询语句只涉及对s1表的单表查询，所以`EXPLAIN`输出中只有一条记录，其中的table列的值是s1，表明这条记录是用来说明对s1表的单表访问方法的。

下边我们看一个连接查询的执行计划:

```mysql
EXPLAIN SELECT * FROM s1 INNER JOIN s2;
```

![img](..\images\mysql\209-04.png)

可以看到这个连接查询的执行计划中有两条记录，这两条记录的`table`列分别是`s1`和`s2`，这两条记录用来分别说明对s1表和s2表的访问方法是什么。

### 2.id

我们写的查询语句一般都以`SELECT`关键字开头，比较简单的查询语句里只有一个SELECT关键字，比如下边这个查语句:

```mysql
SELECT * FROM S1 WHERE key1 = 'a';
```

稍微复杂一点的连接查询中也只有一个SELECT关键字，比如:

```mysql
SELECT * FROM S1 INNER JOIN S2 ON s1.key1 = s2.key1 WHERE  s1.common_field = 'a';
```

但是下边两种情况下在一条查询语句中会出现多个SELECT关键字:

- **查询中包含子查询的情况**

  比如下边这个查询语句中就包含2个SELECT关键字:

```mysql
SELECT * FROM S1 WHERE key1 IN (SELECT key3 FROM s2);
```

- **查询中包含 UNION 语句的情况**

  比如下边这个查询语句中也包含2个SELECT关键字:

```mysql
SELECT * FROM S1 UNION SELECT * FROM s2;
```

**查询语句中每出现一个`SELECT`关键字，MySQL就会为它分配一个唯一的`id`值。**这个id值就是EXPLAIN语句的第一个列，比如下边这个查询中只有一个SELECT关键字，所以EXPLAIN的结果中也就只有一条id列为1的记录：

```mysql
EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
```

![img](..\images\mysql\209-05.png)

对于`连接查询`来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如:

```mysql
 EXPLAIN SELECT * FROM s1 INNER JOIN s2;
```



![img](..\images\mysql\209-04.png)

可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的`id`值都是`1`。这里需要大家记住的是，**在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的**，出现在前边的表表示`驱动表`，出现在后边的表表示`被驱动表`。所以从上边的EXPLAIN输出中我们可以看出，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。

对于包含子查询的查询语句来说，就可能涉及多个`SELECT`关键字，所以在**包含子查询的查询语句的执行计划中，每个`SELECT`关键字都会对应一个唯一的`id`值**，比如这样:

```mysql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
```

![img](..\images\mysql\209-04.png)

从输出结果中我们可以看到，s1表在外层查询中，外层查询有一个独立的`SELECT`关键字，所以第一条记录的id值就是`1`，s2表在子查询中，子查询有一个`独立的SELECT`关键字，所以第二条记录的id值就是`2`。

但是这里大家需要特别注意，**查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询**。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：

```mysql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');
```

![img](..\images\mysql\209-07.png)

可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的 id 值全部是1，这就表明了`查询优化器将子查询转换为了连接查询`。

对于包含`UNION`子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询:

```mysql
EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
```



![img](..\images\mysql\209-08.png)

这个语句的执行计划的第三条记录是什么?为何`id`值是`NULL`，而且table列也很奇怪? `UNION`!它会把多个查询的结果集合并起来并对结果集中的记录`进行去重`，怎么去重呢？MySQL使用的是内部的`临时表`。正如上边的查询计划中所示，UNION子句是为了把id为 1的查询和id为 2的查询的结果集合并起来并去重，所以在内部创建了一个名为`<union1，2>`的临时表(就是执行计划第三条记录的table列的名称)，id为`NULL`表明这个临时表是为了合
并两个查询的结果集而创建的。

跟UNION对比起来，`UNION ALL`就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含UNION ALL子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示:

```mysql
EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;
```



![img](..\images\mysql\209-09.png)

**小结：**

- **id如果相同，可以认为是一组，从上往下顺序执行**
- **在所有组中，id值越大，优先级越高，越先执行**
- **关注点: id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好**

### 3.select_type

一条大的查询语句里边可以包含若千个SELECT关键字，`每个SELECT关键字代表着一个小的查询语句`，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，`每一张表都对应着执行计划输出中的一条记录`，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。

MySQL为每一个SELECT关键字代表的小查询都定义了一个称之为`select_type`的属性，意思是我们只要知道了某个小查询的`select_type属性`，就知道了这个`小查询在整个大查询中扮演了一个什么角色`，我们看一下select_type都能取哪些值，请看官方文档:

| 名称                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| SIMPLE               | Simple SELECT (not using UNION or subqueries)                |
| PRIMARY              | Outermost SELECT                                             |
| UNION                | Second or later SELECT statement in a UNION                  |
| UNION RESULT         | Result of a UNION                                            |
| SUBQUERY             | First SELECT in subquery                                     |
| DEPENDENT SUBQUERY   | First SELECT in subquery, dependent on outer query           |
| DEPENDENT UNION      | Second or later SELECT statement in a UNION, dependent on outer query |
| DERIVED              | Derived table                                                |
| MATERIALIZED         | Materialized subquery                                        |
| UNCACHEABLE SUBQUERY | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
| UNCACHEABLE UNION    | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBOUERY) |

- `SIMPLE`

查询语句中不包含UNION或者子查询的查询都算作是 SIMPLE 类型，比方说下边这个单表查询的select_type 的值就是 SIMPLE:

```mysql
EXPLAIN SELECT * FROM s1;
```



![img](..\images\mysql\209-03.png)

当然，连接查询也算是 SIMPLE 类型，比如:

```mysql
EXPLAIN SELECT * FROM s1 INNER JOIN s2;
```



![img](..\images\mysql\209-04.png)

- `PRIMARY`

对于包含`UNION`、`UNION ALL`或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 值就是PRIMARY，比方说:

```mysql
EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
```



![img](..\images\mysql\209-08.png)

从结果中可以看到，最左边的小查询 SELECT * FROM s1对应的是执行计划中的第一条记录，它的select_type 值就是 PRIMARY。

- `UNION`

对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是UNION，可以对比上一个例子的效果。

- `UNION RESULT`

MySQL 选择使用临时表来完成UNION 查询的去重工作，针对该临时表的查询的 select_type 就是UNION RESULT，例子上边有。

- `SUBQUERY`

如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是不相关子查询，并目查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是SUBQUERY，比如下边这个查询:

```mysql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a':
```



![img](..\images\mysql\209-06.png)

可以看到，外层查询的 select_type 就是PRIMARY，子查询的 select_type就是 SUBQUERY。需要大家注意的是，由于 select_type 为 SUBQUERY 的子查询会被物化，所以只需要执行一遍。

- `DEPENDENT SUBQUERY`

如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是相关子查询，则该子查询的第一个SELECT 关键字代表的那个查询的 select_type就是 DEPENDENT SUBQUERY，比如下边这个查询:

```mysql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 ='a';
```



![img](..\images\mysql\209-10.png)

需要大家注意的是，select_type为 DEPENDENT SUBQUERY的查询可能会被执行多次

- `DEPENDENT UNION`

在包含`UNION`或者`UNION ALL`的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的 select_type 的值就是DEPENDENT UNION。比方说下边这个查询:

```mysql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 ='b');
```



![img](..\images\mysql\209-11.png)

- `DERIVED`

对于包含`派生表`的查询，该派生表对应的子查询的 select type 就是 DERIVED，比如下边的这个查询：

```mysql
EXPLAIN SELECT * FROM (SELECT key1, COUNT(*) AS c FROM s1 GROUP BY key1) AS derived_s1 WHERE c > 1;
```



![img](..\images\mysql\209-12.png)

从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的`select_type`是`DERIVED`，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的 table列显示的是`<derived2>`表示该查询是针对将派生表物化之后的表进行查询的。

> 小贴士: 如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象，大家可以试试

- `MATERIALIZED`

当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就是 MATERIALIZED，比如下边这个查询:

```mysql
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);
```



![img](..\images\mysql\209-13.png)

执行计划的第三条记录的`id`值为`2`，说明该条记录对应的是一个单表查询，从它的 select_type 值为MATERIALIZED 可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的`id`值都为`1`，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的table列的值是`<subquery2>`，说明该表其实就是id为2对应的子查询执行之后产生的物化表，然后将s1和该物化表进行连接查询。

- `UNCACHEABLE SUBQUERY`

不常用，就不多说了。

- `UNCACHEABLE UNION`

不常用，就不多说了。

